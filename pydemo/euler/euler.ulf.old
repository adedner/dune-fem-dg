class Compressible2DEuler:
    def rhoeps(U):
        v = U[1]*U[1]
        for i in range(dim-1): v += U[i+2]*U[i+2]
        v *= 0.5/U[0]
        rE = U[dim]
        return rE - v
    def pressure(U):
        return (gamma-1)*Compressible2DEuler.rhoeps(U)
    def velo(U):
        return [U[i] for i in range(1,dim+1)]
    def toPrim(U):
        return [U[0], Compressible2DEuler.velo(U), U[dim]]
    def F_c(U):
        rho, v, p = Compressible2DEuler.toPrim(U)
        rE = U[dim]
        res = [ rho*v,
               [rho*v[0]*v[0] + p, rho*v[0]*v[1]],
               [rho*v[0]*v[1], rho*v[1]*v[1] + p],
                (rE+p)*v
              ]
    def maxLambda(U,n):
        rho, v, p = Compressible2DEuler.toPrim(U)
        return abs(dot(v,n)) + sqrt(gamma*p/rho)
    def velocity(U):
        return Compressible2DEuler.velo(U)
    def physical(U):
        return conditional( (U[0]>1e-8), conditional( Compressible2DEuler.rhoeps(U) > 1e-8 , 1, 0 ), 0 )
    def jump(U,V):
        pL = Compressible2DEuler.pressure(U)
        pR = Compressible2DEuler.pressure(V)
        return (pL - pR)/(0.5*(pL + pR))

    def outflowFlux(u,n):
        return Compressible2DEuler.F_c(u)*n
    def outflowValue(u):
        return u

    # boundaryFlux = {1: outflowFlux}
    boundaryValue = {1: outflowValue}

Model = Compressible2DEuler

from dune.ufl import Space, NamedConstant
space = Space(2,4)
u = TrialFunction(space)
v = TestFunction(space)

# just a starting point...
def femdgModel(description):
    return inner(description.F_c(u),grad(v))*dx

F = femdgModel(Model)
